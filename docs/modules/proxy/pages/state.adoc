= State Handlers
:toc:
:toclevels: 3

When a client sends a request to the `authorization` endpoint, often a user will have to perform some kind of interaction. For example, logging in or providing consent to the client that is trying to access a resource. This means that the response to the original request to the `authorization` endpoint won't always contain the `authorization code` needed to get an `access_token`. The client might be redirected around before getting such a response. Since the proxy needs to known which response containing an `authorization code` corresponds to a specific request, certain handlers will rely on the https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest[state parameter].

The client can send this state along itself, but it is not required. To make sure that the handlers that need state have access to it, the proxy provides two handlers that can add and remove state if the client did not send it: the `AuthStateRequestHandler` and the `AuthStateResponseHandler`

== Handlers that rely on the State Handlers

* xref:pkce.adoc[PKCE handlers]
* xref:webid.adoc#static_client[ClientIdStaticAuthRequest and Response handlers]

== Configuring the handlers

=== KeyValueStore

The state handlers need a KeyValueStore of some kind so they can store per state whether it was sent by the client, or generated by the proxy:

[source, json]
----
{
    "@id": "urn:dgt-id-proxy:default:StateStore",
    "@type": "InMemoryStore"
},
----

NOTE: In this example we use an `InMemoryStore`, in production you should use a different store!

=== AuthStateRequestHandler

The `AuthStateRequestHandler` can be configured as follows:

[source, json]
----
{
    "@id": "urn:dgt-id-proxy:default:AuthStateRequestHandler",
    "@type": "AuthStateRequestHandler",
    "AuthStateRequestHandler:_keyValueStore": {
        "@id": "urn:dgt-id-proxy:default:StateStore"
    }
}
----

This handler takes the following parameters:

* a `keyValueStore`, which is used to save whether the client sent the state or whether it was generated by the proxy.

=== AuthStateResponseHandler

The `AuthStateResponseHandler` can be configured as follows:

[source, json]
----
{
    "@id": "urn:dgt-id-proxy:default:AuthStateResponseHandler",
    "@type": "AuthStateResponseHandler",
    "AuthStateResponseHandler:_keyValueStore": {
        "@id": "urn:dgt-id-proxy:default:StateStore"
    }
}
----

This handler takes the following parameters:

* a `keyValueStore`, which is used to save whether the client sent the state or whether it was generated by the proxy.

== Configuring the Authorization endpoint

The config for the `authorization` endpoint can be as follows:

[source, json]
----
{
    "@id": "urn:dgt-id-proxy:default:AuthorizationEndpoint",
    "@type": "HttpHandlerRoute",
    "HttpHandlerRoute:_operations": [
        {
            "@type": "HttpHandlerOperation",
            "HttpHandlerOperation:_method": "GET",
            "HttpHandlerOperation:_publish": false
        }
    ],
    "HttpHandlerRoute:_handler": {
        "@type": "PipeThroughHandler",
        "PipeThroughHandler:_handlers": [
            {
                "@id": "urn:dgt-id-proxy:default:AuthStateRequestHandler"
            },
            {
                "@id": "urn:dgt-id-proxy:default:PassThroughHandler"
            }
            {
                "@id": "urn:dgt-id-proxy:default:AuthStateResponseHandler"
            }
        ]
    },
    "HttpHandlerRoute:_path": "/auth"
},
{
    "@id": "urn:dgt-id-proxy:default:AuthorizeResumeEndpoint",
    "@type": "HttpHandlerRoute",
    "HttpHandlerRoute:_operations": [
        {
            "@id": "urn:dgt-id-proxy:default:GetOperation"
        }
    ],
    "HttpHandlerRoute:_handler": {
        "@type": "PipeThroughHandler",
        "PipeThroughHandler:_handlers": [
            {
                "@id": "urn:dgt-id-proxy:default:PassThroughHandler"
            },
            {
                "@id": "urn:dgt-id-proxy:default:AuthStateResponseHandler"
            }
        ]
    },
    "HttpHandlerRoute:_path": "/authorize/resume"
}
----

The `AuthStateRequestHandler`, as the name suggests, only handles and returns requests, and the `AuthStateResponseHandler` only handles and returns responses. The `PipeThroughHandler` is a handler that sends what was passed to it (in this case it will start with a request) and passes it to the first handler in the list. Whatever that handler returns will be passed to the second, and so on.

The flow here would be:

. A request reaches the `authorization` endpoint and is passed by the `PipeThroughHandler` to the first handler.
. The `AuthStateRequestHandler` checks if the request contains state. If it does, it uses the client sets the state as key in its `keyValueStore` with a value of `true` to indicate that the client sent this state. If the request does not have a state, the handler generates one, adds it to the request, and sets it in its `keyValueStore` with a value of `false`. It then returns the request.
. The request, which is now guaranteed to have a state parameter is then passed to handlers which will use the request and eventually get a response from the upstream server. In this example it's simply a xref:getting_started.adoc#passthrough[PassThroughHttpRequestHandler] which sends the request to the upstream server and returns the response.
. The response is then passed to the `AuthStateResponseHandler` which checks that the response contains a state. If the user was already logged in, the response here will be a redirect response, and the state will be on the location header. The handler finds the state in it`s store and, if the value is true leaves the state on the request, but if the value is false it removes state from the request as the client did not originally send it. It then returns the response, and the response is sent back to the client.
+
However, if the user was not logged in the response will most likely be an html page containing a login form. After the user has logged in and given consent the redirect response will be sent on a slightly different endpoint, which is why the `AuthStateResponseHandler` must be configured on that endpoint aswell, in this example the /authorize/resume endpoint.


