= Proof Key for Code Exchange (PKCE)

Enabling PKCE requires the configuration of the following handlers:

* For `authorization`:
** `PkceAuthRequestHandler`. This handler will handle the pkce request before sending it on the the upstream server, but it won't do anything with the response.
** `PkceCodeRequestHandler`. This handler will handle the response that contains the code with which a token can be requested.
* For a `token`:
** `PkceTokenRequestHandler`. This handler will handle the pkce request to the token endpoint.

The reason that the `authorization` portion is split into two seperate handlers is because many Identity Providers will redirect the user to a login page and/or a consent page before returning a response with the code. Since these would be split into seperate requests and responses, the proxy needs to be able to catch the authorization code on different endpoints. If the user is already logged in, then the first request would get a response containing a code if everything went right.

== Configuration

=== KeyValueStore

To facilitate PKCE we need to store some information. All handlers will need access to the same information, so they will share a store. For this example, we'll configure an `InMemoryStore` and give it an id so we can reference it in our other handlers:

```
{
    "@id": "urn:dgt-id-proxy:default:PkceStore",
    "@type": "InMemoryStore"
}
```

=== Authorization endpoint

The handlers for the `authorization` endpoint can be configured as follows:

* `PkceAuthRequestHandler`:
+
```
{
    "@id": "urn:dgt-id-proxy:default:PkceAuthRequestHandler",
    "@type": "PkceAuthRequestHandler",
    "PkceAuthRequestHandler:_codeHandler": {
        "@id": "urn:dgt-id-proxy:default:PkceCodeRequestHandler"
    },
    "PkceAuthRequestHandler:_store": {
        "@id": "urn:dgt-id-proxy:default:PkceStore"
    }
}
```
+
This handler requires a handler, specifically a `codeHandler`, to which it can pass its request when it has finished validating the PKCE request. We give it the `PkceCodeRequestHandler`. It also needs a `store` as mentioned above in which it can store the `code_challenge` and `challenge_method` associated with the request.

* `PkceCodeRequestHandler`:
+
```
{
    "@id": "urn:dgt-id-proxy:default:PkceCodeRequestHandler",
    "@type": "PkceCodeRequestHandler",
    "PkceCodeRequestHandler:_httpHandler": {
        "@id": "urn:dgt-id-proxy:default:PassThroughHandler"
    },
    "PkceCodeRequestHandler:_store": {
        "@id": "urn:dgt-id-proxy:default:PkceStore"
    }
}
```
+
This handler requires a `httpHandler`, in this example we will use a xref:getting_started.adoc#passthrough[PassThroughHttpRequestHandler]. It also requires a store, so it can link the code it receives from the upstream server with the `code_challenge` and `challenge_method` that the user sent to get the code.

=== Token endpoint

On the `token` endpoint only one handler is required, the `PkceTokenRequestHandler`:

```
{
    "@id": "urn:dgt-id-proxy:default:PkceTokenRequestHandler",
    "@type": "PkceTokenRequestHandler",
    "PkceTokenRequestHandler:_httpHandler": {
        "@id": "urn:dgt-id-proxy:default:PassThroughHandler"
    },
    "PkceTokenRequestHandler:_store": {
        "@id": "urn:dgt-id-proxy:default:PkceStore"
    }
}
```

This handler also requires a `httpHandler, in this example we will use a xref:getting_started.adoc#passthrough[PassThroughHttpRequestHandler] on the `token` endpoint as well. It also requires the a `store`, the same store as the other handlers.


== Putting it together

We will need to configure three seperate endpoints. The authorization endpoint, the token endpoint, and the endpoint to which the client is redirected after a successful login:

```
{
    "@id": "urn:dgt-id-proxy:default:AuthenticationEndpoint",
    "@type": "HttpHandlerRoute",
    "HttpHandlerRoute:_operations": [
        {
            "@type": "HttpHandlerOperation",
            "HttpHandlerOperation:_method": "GET",
            "HttpHandlerOperation:_publish": false
        }
    ],
    "HttpHandlerRoute:_handler": {
        "@id": "urn:dgt-id-proxy:default:PkceAuthRequestHandler"
    },
    "HttpHandlerRoute:_path": "/auth"
},
{
    "@id": "urn:dgt-id-proxy:default:AuthenticationDynamicEndpoint",
    "@type": "HttpHandlerRoute",
    "HttpHandlerRoute:_operations": [
        {
        "@type": "HttpHandlerOperation",
        "HttpHandlerOperation:_method": "GET",
        "HttpHandlerOperation:_publish": false
        }
    ],
    "HttpHandlerRoute:_handler": {
        "@id": "urn:dgt-id-proxy:default:PkceCodeRequestHandler"
    },
    "HttpHandlerRoute:_path": "/auth/:dynamic"
},
{
    "@id": "urn:dgt-id-proxy:default:TokenEndpoint",
    "@type": "HttpHandlerRoute",
    "HttpHandlerRoute:_operations": [
        {
            "@type": "HttpHandlerOperation",
            "HttpHandlerOperation:_method": "POST",
            "HttpHandlerOperation:_publish": false
        },
        {
            "@type": "HttpHandlerOperation",
            "HttpHandlerOperation:_method": "OPTIONS",
            "HttpHandlerOperation:_publish": false
        }
    ],
    "HttpHandlerRoute:_handler": {
        "@id": "urn:dgt-id-proxy:default:PkceTokenRequestHandler"
    },
    "HttpHandlerRoute:_path": "/token"
}
```
NOTE: All endpoints are Identity Provider specific. Change the endpoints to match the endpoints of the upstream server you are proxying.

The flow here will be:

. A request for an authorization code is sent to the `authorization` endpoint.
. The request is passed to the `PkceAuthRequestHandler`, which takes the `code_challenge` and `challenge_method` and saves them in a `store`, then strips the PKCE parts from the request and sends it PKCE-less to its handler.
. The handler, in this case the `PkceCodeRequestHandler` passes the request on, as it needs the response with a code.
. The request reaches the `PassThroughHttpRequestHandler`, which sends the request to the upstream, and returns the response. If the user is logged in, and the request was successful, the response will contain the authorization code. But in this example, let's say the user is not logged in yet.
. The request would go back to the `PkceCodeRequestHandler`, but since there is no code in the request, it will ignore it and pass it up the chain untill it is eventually returned to the client.
. After the user logs in and gives consent to authorize the client, the upstream server will return a response containing an authorization code. The `PkceCodeRequestHandler` will take that code and match it to the request that contained the `code_challenge` and `challenge_method` for that code, and save the code in the store, and return the response.
. The client will request a token with the authorization code it received. The `PkceTokenRequestHandler` will find the code in the store and the matching `code_challenge` and `challenge_method`, and then check the `code_verifier` sent by the client to see if they match. If they do, the request will be passed on again, and the client will get a response from the upstream server containing an Access Token!