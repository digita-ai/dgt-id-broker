= Classic OIDC vs Solid OIDC
:toc:
:toclevels: 1
:imagesdir: ../img

This document provides a close comparison of classic OpenID Connect (OIDC) and Solid OIDC. We will demonstrate the differences between the classic OIDC flow and the Solid OIDC flow, as the latter requires some crucial additions to the former.


== Concepts

Resource Server (RS) :: A server hosting resources, possibly protected by access control policies.
      
Solid Pod :: A (virtual) root container on a Solid-compliant *Resource Server*.

Resource Owner :: An entity capable of granting other entities permissions (e.g. access rights) to protected resources.

End-User :: Originally meant as a synonym for human *Resource Owners*, here used to refer to the entity to which the permission is granted.

OAuth 2.0 :: An authorization framework enabling applications to obtain permissions for certain resources on behalf of an *End-User*.

OpenID Connect (OIDC) :: An authentication framework on top of the *OAuth 2.0* protocol, enabling applications to verify the identity of the *End-User*.

Authorization Server (AS) :: A system implementing the authoritative part of an _authorization_ framework (in casu *OAuth 2.0*).

Identity Provider (IdP) :: A system implementing the authoritative part of an _authentication_ framework (in casu *OpenID Connect*).

Client | Relying Party (RP) :: An application relying on an *Identity Provider* in order to access data or perform actions on behalf of the *End-User*.

Client ID :: An identifier used to register the *Client* with the *Identity Provider*.

Client secret :: A credential for the *Client* registered with the *Identity Provider*.

Redirect URI | Callback URL :: A URL to which the *Identity Provider* will redirect the user agent during the authentication flow.

Claim :: An authoratitive piece of information the *Identity Provider* can provide about the *End-User*.

Scope :: An indication of the *Claims* the *Client* would like the *Identity Provider* to provide.

Consent :: An affirmative action of the *Resource Owner* granting requested *Claims* to be provided to the *Client*. 

Grant Type :: The way in which the *Client* will authenticate itself when requesting the *Claims* from the *Identity Provider*.

Response Type :: The way in which the *Client* expects to receive the *Claims* from the *Identity Provider*. 

Authorization Code :: A secure *Response Type* in the form of a temporary code, which the *Client* can exchange for the *Claims*. 

Access Token :: A JSON Web Token (JWT) the *Client* obtains from an *Authorization Server*, containing *Claims* that grant permissions to access data or perform actions on a *Resource Server* on behalf of the *End-User*.

ID Token :: A JWT the *Client* obtains from an *Identity Provider*, containing *Claims* that prove the identity of the *End-User*.

WebID :: A *WebID* is an HTTP(S) URI which represents an Agent (Person, Organization, Group, Device, etc.) as defined in the link:https://dvcs.w3.org/hg/WebID/raw-file/tip/spec/identity-respec.html#introduction[WebID 1.0 specification].

PKCE :: Proof Key for Code Exchange, is a security extension to the OAuth 2.0 Authorization Code flow for preventing code injection and man in the middle attacks, by linking the authorization request to the token request using a code.

Code Verifier ::  A cryptographically random string of 43 to 128 characters, which is generated by the *Client* in the *PKCE* process, and sent with the token request in order to verify the exchange.

Code Challenge ::  A transformation of the *Code Verifier*, often a base 64 encoding of a SHA256 hash thereof, used in the *PKCE* process, which is sent in the authorization request to be verified against later.

Code Challenge Method :: The method that was used to generate the *Code Challenge* from the *Code Verifier* _(e.g. SHA256)_.

DPoP :: Demonstration of Proof-of-Possession, is a security extension to OAuth 2.0, binding access and refresh tokens to a specific *Client* to prevent replay attacks. 

DPoP Header :: A JWT containing the *Client*s public key, as well as some request information (method and url) signed with the private key. Using the same key pair, one is generated for the *Token* request and one for the request to the *Resource Server*.

DPoP-Bound Token :: A sender-constrained *Token* issued by the *Authorization Server* by including a confirmation of the public key present in the *DPoP Header* (e.g. the JWK thumbprint).

Static Client Registration :: The manually registration of a *Client*, with its metadata (e.g. its *Redirect URI*), to an *Authorization Server*.

Dynamic Client Registration :: A mechanism that enables *Client*s to be registered (with their metadata) to the *Authorization Server* programmatically.

Registration Endpoint :: The optional API endpoint of the *Identity Provider* where a *Client* can request to be registered.

Authorization Endpoint :: The API endpoint of the *Identity Provider* where a registered *Client* can identify itself in order to get an *Authorization Code* for requesting a token. In classic OIDC, such identification consists of the *Client ID*, the *Redirect URI*, the *Scope* and the *Response Type*; in Solid OIDC, this is extended with the *PKCE* *Code Challenge* and *Code Challenge Method*.

Token Endpoint :: The API endpoint of the *Identity Provider* where an authorized *Client* can request tokens. In classic OIDC, such a request consists of the *Client ID*, the *Redirect URI*, the *Grant Type* and the *Authorization Code*; in Solid OIDC, this is extended with the *PKCE* *Code Verifier*, and must be accompanied with a *DPoP Header*.

WebID Verification :: Upon receiving a *WebID* as *Client ID*, the *Authorization Server* can retrieve it's profile as a third way of client registration. The *WebID* must contain a _solid:oidcRegistration_ triple containing the parameters required for registering. Upon verification these parameters are compared to the parameters provided in the authorization request. 

== Example

Throught this document, we will use the following example to illustrate the differences between the classic OIDC flow and the Solid-compliant one.

Imagine Alice wants to use a web service called Daily Pictures that will post a picture to her social feed every day on her behalf. Alice wants to give Daily Pictures consent to let it access the photo collection stored in her Solid Pod, and grant it permissions to create posts on her social feed.


== Classic OIDC 

Using classic OIDC, the following flow would suffice to give Daily Pictures access to Alice's pod, and in a similar way she could give it access to her social feed. This flow does, however, contain significant security issues, and is less interoperable within the fully compliant Solid ecosystem.

. Alice browses to the *Client's* (Daily Pictures) web page.

. She selects her choice of *Identity Provider*, like Google or Facebook, with which she should already have registered an account. The *Client* can either provide choices as a predefined list, or allow Alice to enter the *Identity Provider's* URI (e.g. `secureauth.org`).

. Now that it knows Alice's *Identity Provider*, the *Client* must retrieve its configuration, which describes everything the *Client* needs to know to identify Alice's. This configuration, if not stored in memory, can always be found at the `/.well-known/openid-configuration` path relative to the *Identity Provider's* URI, and will look somewhat like this: 
+
[source, json]
----
{
    "issuer": "https://secureauth.org",
    "authorization_endpoint": "https://secureauth.org/authorize",
    "token_endpoint": "https://secureauth.org/token",
    "userinfo_endpoint": "https://secureauth.org/userinfo",
    "registration_endpoint": "https://secureauth.org/register",
    "end_session_endpoint": "https://secureauth.org/endsession",
    "jwks_uri": "https://secureauth.org/jwks",
    "response_types_supported": [ "code" ],
    "grant_types_supported": [ "authorization_code", "refresh_token" ],
    "subject_types_supported": [ "public" ],
    "claims_supported": [ "sub", "webid" ],
    "scopes_supported": [ "openid", "profile", "email", "offline_access" ],
    "token_endpoint_auth_methods_supported": [ "client_secret_basic" ],
    "token_endpoint_auth_signing_alg_values_supported": [ "ES256" ],
    "request_object_signing_alg_values_supported": [ "ES256" ],
    "id_token_signing_alg_values_supported": [ "ES256" ],
    "claims_parameter_supported": false,
    "request_parameter_supported": true,
    "request_uri_parameter_supported": false,
    "require_request_uri_registration": false
}
----
+
In particular, notice the endpoint parameters: `registration_endpoint`, `authorization_endpoint` and `token_endpoint`, as well as the `jwks_uri`.

. Important in the classic OIDC flow is that the *Client* should be registered with the *Identity Provider* beforehand as well. This can either be a static registration, in the case of a select list of providers, or a dynamic one. For the latter, the *Client* can use the *Registration Endpoint* of the configuration to request it's registration. This enables the *Client* to register itself with any *Identity Provider* Alice may enter, even if it does not know it yet.

. The registered *Client*, can then redirect Alice's web browser to the *Authorization Endpoint* of the *Identity Provider*, which is an OIDC *Authorization Server*. This request contains the *Client ID*, *Redirect URI*, *Response type* and the *Scopes* that are needed. Among these there is a specific `openid` *Scope* that lets the *Authorization Server* know this will be a an OIDC exchange, and it will thus need to act like an *Identity Provider*. This request is made with the following parameters:
+
* *response_type* : The expected type of response data, `code` being the most secure (used in this example).
* *redirect_uri* : This is the URL where the *Identity Provider* will redirect to when Alice has successfully logged in.
* *scope* : The list of OIDC scopes
** *open_id* : is required to use the *Authoorization Server* as an *Identity Provider*, and get an *ID Token*.
** *offline_access* : is optional, to get a *Refresh Token*.
* *client_id* : the identifier with which the *Client* is registered at the *Identity Provider* through static or dynamic registration.
+
The request will then look like the following:
+
[source, json]
----
GET https://secureauth.org/authorize?response_type=code&redirect_uri=https%3A%2F%2Fdailypictures.example%2Fcallback&scope=openid%20profile%20offline_access&client_id=dailypictures
----
+

. The *Identity Provider* now takes over the user experience to verify Alice's identity, if necessary by prompting for a login. This can be done by a number of authentication methods, a password for instance. 

. The *Identity Provider* presents Alice with a *Consent* form that is based on the *Scopes* the *Client* requested. By accepting them, Alice can grant these permissions to the *Client*. In the example, she grants Daily Pictures access to the photo collection in her Solid Pod.

. When Alice has logged in, the *Identity Provider* will generate a cryptographic random string as *Authorization Code*, and stores it with the request parameters. It then redirects Alice back to the *Client's* *Redirect URI*, appending the *Authorization Code*: `https://dailypictures.example/callback?code=h-DnHRAfTsn9V_m4I1A3Cw`.

. The *Client* can now send a request to the *Token Endpoint* of the *Identity Provider* and includes it's *Client ID*, *Client secret* and the *Authorization code*.

. The *Identity Provider* verifies this data and responds with an *Access Token*, an *ID Token*, and optionally a *Refresh Token*.

. The *Client*, in our case Daily Pictures, can now use these tokens to send requests to the *Resource Server*, in our case Alice's pod, in order to daily find a new picture for her social feed.

[#img-classic-oidc]
.A Classic OIDC Flow
image::classic-oidc-flow.jpg[Classic OIDC Flow]


== Solid OIDC

==== Flow

. Alice browses to the *Client's* (Daily Pictures) web page.

. In this Solid-compliant flow, there is another alternative option for Alice to indicate her *Identity Provider*: she can enter her own WebID (e.g. `alice.digital-id.net`), upon which the *Client* can request her WebID profile document to determine her *Identity Provider*. Such a document could look somewhat like this: 
+
[source, json]
----
@prefix : <#>.
@prefix solid: <http://www.w3.org/ns/solid/terms#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.
@prefix schema: <http://schema.org/>.

<>
    a foaf:PersonalProfileDocument ;
    foaf:maker <https://alice.digital-id.net> ;
    foaf:primaryTopic <https://alice.digital-id.net> .

:me a foaf:Person ;
    a schema:Person ;
    foaf:name "Alice" ;
    solid:oidcIssuer <https://secureauth.org> ;
----
+
The URI of the *Identity Provider* is the value of the `solid:oidcIssuer` triple.

. Now that it has the URI of Alice's *Identity Provider*, the *Client* must retrieve its configuration, just like in the classic flow. To be solid-compliant, such a configuration should contain two extra parameters: `"solid_oidc_supported": "https://solidproject.org/TR/solid-oidc"`, indicating its compliance, and `"code_challenge_methods_supported"`, which should contain a list of accepted method for the *PKCE* extension.

. To be Solid-compliant, the *Client* must now use the secure link:url[PKCE, https://oauth.net/2/pkce/] enhancement to OIDC. To do so, it first needs to generate a *code verifier*. This can be a cryptographic random string (e.g. `LDKoTiFC6`). By encoding this code verifier with a *challenge method*  (e.g. `BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))`) we can create our *code challenge* (e.g. `92d5a871f52a513951e3260cd42b04f29b0f4a8bfea1740a0780e3db667`).

. Note that in this flow, it is not necessary for the *Client* to be registered beforehand with the *Identity Provider*. Instead, the *Client* can use a URL as its *Client ID* that dereferences to a JSON-LD serialized RDF document with its registration parameters. For example: 
+
[source, json]
----
...
----
+
If the Solid-compliant *Identity Provider* receives a request with such a *Client ID*, it should always check the request parameters with the ones in that document.
+
Alternatively, the *Client* can present itself as an ephemeral, anonymous public client by using the *Client ID* `http://www.w3.org/ns/solid/terms#PublicOidcClient`. In such cases, the Solid-compliant *Identity Provider* must accept the request, taking any *Redirect URI* to be valid.

. After generating the *PKCE* parameters, an authorization request can be made to the *Authorization Endpoint*. This request looks the same as in the classic flow, with an extra `profile` *Scope* to request the *WebID* of the *End-User* (Alice), the extra *PKCE* parameters described above, and the possibility of a URI as *Client ID*:
+
[source, json]
----
GET https://secureauth.example/authorize?response_type=code&redirect_uri=https%3A%2F%2Fdailypictures.example%2Fcallback&scope=openid%20profile%20offline_access&client_id=https%3A%2F%2Fdailypictures.example%2Fwebid%23this&code_challenge_method=S256&code_challenge=92d5a871f52a513951e3260cd42b04f29b0f4a8bfea1740a0780e3db667
----
+

. Finally Alice is prompted to login by the *Identity Provider*. This happens identical to the classic flow, with the remark that the stored request parameters now also contain the *PKCE* parameters.

. After receiving the *Authorization Code*, the *Client* must now generate a DPoP token. This DPoP token will make it possible for third party web applications to send requests to multiple *Pods* in addition to making sure malicious *Pods* are not able to get a hold of Alice's token.
.. The first step to achieve this is is for the *Client* to generate both a public key and a private key. 
+
[source, json]
----
Private key:
{
    "kty": "EC",
    "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
    "use": "sig",
    "alg": "EC",
    "crv": "P-256",
    "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
    "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s",
    "d": "RrM4Ou_7PzjP24B4k06B9ZML16HbfzNPKFN11Z8c9_s"
}

Public key:
{
    "kty": "EC",
    "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
    "use": "sig",
    "alg": "EC",
    "crv": "P-256",
    "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
    "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s"
}

----

. Next we need to generate our DPoP header. We can achieve this by creating a *JSON Web Token* and singing it with the key we just generated. 
This JWT will look somewhat like this: 
+

----
eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0IiwiandrIjp7Imt0eSI6IkVDIiwia2lkIjoiZkJ1STExTkdGbTQ4Vlp6RzNGMjVDOVJmMXYtaGdEakVnV2pEQ1BrdV9pVSIsInVzZSI6InNpZyIsImFsZyI6IkVDIiwiY3J2IjoiUC0yNTYiLCJ4IjoiOWxlT2gxeF9IWkhzVkNScDcyQzVpR01jek1nUnpDUFBjNjBoWldfSFlLMCIsInkiOiJqOVVYcnRjUzRLVzBIYmVteW1vRWlMXzZ1cko0TFFHZXJQZXVNaFNEaV80In19 
----
+
When decoded the *Token Header* will look like this:
+
[source, json]
----
{
    "alg": "ES256",
    "typ": "dpop+jwt",
    "jwk": {
        "kty": "EC",
        "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
        "use": "sig",
        "alg": "EC",
        "crv": "P-256",
        "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
        "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s"
    }
}
----
+

* *"alg"* : This tells us the token was signed using the ES256 algorithm.
* *"typ": "dpop+jwt"* : This is the type of the token. Every DPoP Token should have the type `"dpop+jwt"`.
* *"jwk"* : The value for this key is the actual *Client*'s public key.
+

//dit indent een laag te ver
The *Token Body* contains the following:
+
[source, json]
----
{
    "htu": "https://secureauth.example/token",
    "htm": "POST",
    "jti": "4ba3e9ef-e98d-4644-9878-7160fa7d3eb8",
    "iat": 1603306128
}
----
+

* *"htu"*: The token will only be able to be used for the given URL.

* *"htm"*: This indicates that only POST requests can be made with this.

* *"jti"*: This is a unique identifier for the DPoP token that can be used by the server to defend against replay attacks.

* *"iat"*: A UNIX timestamp of the date the token was issued.
+

. Finally the *Client* can create an authentication request. This can be done by sending an AJAX request to the token endpoint which was defined in the *OP*'s open-id configuration we retrieved earlier.
+
[source, json]
----
POST https://secureauth.example/token
Headers: {
  "DPoP": "eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0IiwiandrIjp7Imt0eSI6IkVDIiwia2lkIjoiZkJ1STExTkdGbTQ4Vlp6RzNGMjVDOVJmMXYtaGdEakVnV2pEQ1BrdV9pVSIsInVzZSI6InNpZyIsImFsZyI6IkVDIiwiY3J2IjoiUC0yNTYiLCJ4IjoiOWxlT2gxeF9IWkhzVkNScDcyQzVpR01jek1nUnpDUFBjNjBoWldfSFlLMCIsInkiOiJqOVVYcnRjUzRLVzBIYmVteW1vRWlMXzZ1cko0TFFHZXJQZXVNaFNEaV80In19.eyJodHUiOiJodHRwczovL3NlY3VyZWF1dGguZXhhbXBsZS90b2tlbiIsImh0bSI6InBvc3QiLCJqdGkiOiI0YmEzZTllZi1lOThkLTQ2NDQtOTg3OC03MTYwZmE3ZDNlYjgiLCJpYXQiOjE2MDMzMDYxMjgsImV4cCI6MTYwMzMwOTcyOH0.2lbgLoRCkj0MsDc9BpquoaYuq0-XwRf_URdXru2JKrVzaWUqQfyKRK76_sQ0aJyVwavM3pPswLlHq2r9032O7Q",
  "content-type": "application/x-www-form-urlencoded"
}
Body:
  grant_type=authorization_code&
  code_verifier=LDKoTiFC6
  code=h-DnHRAfTsn9V_m4I1A3Cw
  redirect_uri=https%3A%2F%2Fdailypictures.example%2Fcallback&
  client_id=https%3A%2F%2Fdailypictures.example%2Fwebid%23this
---- 
+
* *headers.DPoP*: This is the JSON Web Token we created earlier, when decoded it contains the the *Client*'s public key.

* *headers.content-type* : This sets the headers content type. Usually this will be _application/x-www-form-urlencoded_ but some *OP*'s will also accept _application/json_. Do note that they all must access urlencoded content types. That is why this is preferred.

* *body.grant_type* : This informs the *OP* this is part of an authorization flow.
* *body.code_verifier*: This is the *code verifier* that was stashed in our session storage earlier.

* *body.code* : This contains the code we received earlier as a parameter string upon redirect. 

* *body.redirect_uri* : The *Client*'s redirect url. Because this is an AJAX request.

* *body.client_id* : The *Client*'s client id.

. The *OP* will now compare the code that was store in the keystore with 
the `client_id` in the request. If these do not match it is required to send a 403 response.

. The *OP* will get the *Client*'s public key (a JSON Web Key) from the DPoP header, stored in the JWT, and checks if the DPoP token contains a valid signature. If not it is required to send a 403 response.

 . Now the JWK public key must be places inside the access token. Before we can do so it needs to be converted into a JWK thumbprint (`9XmwK8mQ3H5-PnzAt3lFHzWBW_v5QhYynezbbit4kC8`). 

. An access token can now be generated by the *OP*. It will create a JWT and sign it using it's own keys. 
+
When decoded it will look somewhat like this:
+
[source, json]
---- 
Token Header:

{
    "alg": "ES256",
    "typ": "JWT"
}
"alg": "ES256": indicates the token was signed using eliptic curve

"typ": "JWT": indicates that this is a JSON web token

Token Body:

{
    "webid": "https://alice.digipod.example/profile/card#me",
    "iss": "https://secureauth.example",
    "aud": "solid",
    "cnf": {
        "jkt": "9XmwK8mQ3H5-PnzAt3lFHzWBW_v5QhYynezbbit4kC8"
    },
    "client_id": "https://dailypictures.example/webid#this",
    "jti": "fd0a1353-25f3-4c7e-8f8b-c14264f1c12e",
    "iat": 1603385261,
    "exp": 1603385861
}
---- 
+

* *"webid"* : This contains Alice's WebID.
* *"iss"* : The *OP* used to create this token.
* *"aud"* : The token’s audience. The audience for a solid token is simply: "solid".
* *"cnf"* : The JWT thumbprint we created earlier stored with the "jkt" key.
* *"client_id"* : This contains the client id of the *Client*.
* *"iat": 1603370641* : A UNIX timestamp of the date the token was issued.
* *"exp": 1603371241* : A UNIX timestamp of the expiration date.

. The *OP* generates an *ID Token* since the `openid` scope was included in the authorization request. This will only be used to communicate with the *Client*. It consists of a JWT. 
+
When decoded it will look somewhat like this:
+
[source, json]
---- 
Token Header:

{
    "alg": "ES256",
    "typ": "JWT"
}
"alg": "ES256": This indicates the token was signed using the ES256 algorithm.

"typ": "JWT": This indicates that this is a JSON web token.

Token Body:

{
    "sub": "https://alice.digipod.example/profile/card#me",
    "aud": "https://dailypictures.example/webid#this",
    "webid": "https://alice.digipod.example/profile/card#me",
    "iss": "https://secureauth.example",
    "jti": "844a095c-9cdb-47e5-9510-1dba987c0a5f",
    "iat": 1603370641,
    "exp": 1603371241
}
---- 
+

* *"sub"* :  The subject claim. This must be the same as the WebID of the user that was authenticated.
* *"aud"* :  The token’s audience. Because an id_token is required for the *Client*, its audience is the client id.
* *"webid"* : This contains Alice's WebID.
* *"iss"* :   The *OP* used to create this token.
* *"jti"* :  This is a unique identifier for the DPoP token that can be used by the server to defend against replay attacks.
* *"iat"* :  A UNIX timestamp of the date the token was issued.
* *"exp"* : A UNIX timestamp of the expiration date.

. In case _offline_access_ was added as a scope the *OP* will create a refresh token.
This could be a JWT but does not necessarily have to.
+

The example token would decrypt as:
+
[source, json]
---- 
Token Header:

{
    "alg": "none"
}
Token Body:

{
    "jti": "a78b49ef-71c5-4985-a50c-5ef3aef0fd8f"
}
---- 
+

CAUTION: Make sure to save this token into a persistent store.
+

. If everything checks out the *OP* will reply with a response that contains all generated tokens in the body.
+
[source, json]
---- 
{
    "access_token": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwiYXVkIjoic29saWQiLCJjbmYiOnsiamt0IjoiOVhtd0s4bVEzSDUtUG56QXQzbEZIeldCV192NVFoWXluZXpiYml0NGtDOCJ9LCJjbGllbnRfaWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJqdGkiOiJmZDBhMTM1My0yNWYzLTRjN2UtOGY4Yi1jMTQyNjRmMWMxMmUiLCJpYXQiOjE2MDMzODUyNjEsImV4cCI6MTYwMzM4NTg2MX0.HIIYiovILPvsdkD3s3xomR1MkA_Ir8Mx_C-eHxbWEnw9Z2rv2rOWbvMPZ--BqH3qVSupgYTZZsTDbZXA8giCLA",
    "expires_in": 300,
    "token_type": "DPoP",
    "id_token": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJhdWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwianRpIjoiODQ0YTA5NWMtOWNkYi00N2U1LTk1MTAtMWRiYTk4N2MwYTVmIiwiaWF0IjoxNjAzMzg2NDQ4LCJleHAiOjE2MDMzODcwNDh9.T306vT8dmn9gQIMEdG92AM4WRnrhqWZTfDpovwqZ6Zn0mK9yxj0iOVGqXD4CW8-tzDTitNwEGorAo85atL0Oeg",
    "refresh_token": "eyJhbGciOiJub25lIn0.eyJqdGkiOiJhNzhiNDllZi03MWM1LTQ5ODUtYTUwYy01ZWYzYWVmMGZkOGYifQ.",
    "scope": "openid profile offline_access"
}
----
+
* *"access_token"* : The generated *access token*, the *Client* will use to authenticate with the server.
* *"expires_in"* : This tell us that this access token will be valid for 5 minutes (300 seconds).
* *"token_type"* : The type of token that was granted (DPoP). 
* *"id_token"* : The generated id token. The *OP* will use to retrieve data from Alice's WebId.
* *"refresh_token"* : This token will be used to retrieve a new *access token* when the previous one expired.
* *"scope"* : The scopes that were used. Or in other words, the permissions that were granted to the *Client*.


Finally the *Client* can start making requests to Alice's *Solid Data Pod* to retrieve pictures and post one daily on her social feed.

[#img-solid-oidc]
.B Solid OIDC Flow Chart
image::solid-oidc-chart.jpg[Solid Flow]

== Summary

Solid-OIDC spec is basically OIDC Discovery, followed by the OIDC Authorization Code Flow with the OAuth2.0 PKCE extension, using a DPoP-bound access token, and making TLS mandatory for communication and WebIDs mandatory as identifiers. Concretely, Solid OIDC adds the following requirements to classic OIDC. 

For users ::

* Should provide a webID that is a valid RDF profile. This webID will be a part of the OIDC ID Token that is provided by the IdP for authentication.

For clients ::

* Clients SHOULD use a webID as their client ID. If they do, it MUST resolve to a valid RDF document. This document MUST include a single `solid:oidcRegistration` property, which in turn MUST be a JSON serialization of an OIDC client registration.
* When requesting a DPoP-bound Access Token from an Identity Provider, the client must send a valid DPoP proof JWT.

For Identity Providers ::

* An IdP MUST dereference the client’s WebID to a document containing a JSON serialization of OAuth 2.0 Dynamic Client Registration metadata, and match any client-supplied request parameters. (Non-WebID clients are also allowed if registered with the server. Ephemeral clients can use the identifier `http://www.w3.org/ns/solid/terms#PublicOidcClient`, upon which the server may accept any redirect uri.)
* IdPs MUST provide a DPoP-bound Access Token to the client. This token must be a valid JWT token containing:
** `webid` — must provide the user's webID.
** `iss` — must be a valid URL of the IdP instantiating this token.
** `aud` — must either be the string `solid` or be an array of values, one of which is the string `solid`.
** `iat` — the time at which the DPoP-bound Access Token was issued as a UNIX timestamp.
** `exp` — the time at which the DPoP-bound Access Token becomes invalid as a UNIX timestamp.
** `cnf` — the confirmation claim is used to identify the DPoP Public Key bound to the Access Token.
** `client_id` — The ClientID claim is used to identify the client.
* IdPs MUST also provide the user with an OIDC ID token. In Solid OIDC the user's webID MUST be present in this token as the `webid` claim.
* An IdP that conforms to the Solid-OIDC specification MUST advertise this in the OpenID Connect Discovery 1.0 resource, with `"solid_oidc_supported": "https://solidproject.org/TR/solid-oidc"`.

For Resource Servers ::

* A Resource Server must inform the Client that a DPoP-bound Access Token is required upon request of a non-public resource.
* A resource server must dereference the WebID in the access token and check it against the iss claim in the Access Token.
* A Resource Server must get the public key from an IdP and use it to validate the signature on the DPoP-bound Access Token that was sent by the client upon every request.


== Sources 


=== Specifications

- link:https://solid.github.io/authentication-panel/solid-oidc[Solid OIDC] (and link:https://solid.github.io/authentication-panel/solid-oidc-primer[primer])
- link:https://tools.ietf.org/html/rfc7591[Dynamic Client Registration]
- link:https://tools.ietf.org/html/draft-ietf-oauth-dpop-01[DPoP]
- link:https://tools.ietf.org/html/rfc7636[PKCE]


=== Other useful links

- link:https://developer.okta.com/blog/2019/10/21/illustrated-guide-to-oauth-and-oidc[Intro to OAuth and OIDC]
- link:https://docs.inrupt.com/ess/security/authentication[Inrupt's overview of WebID and DPoP in Solid]
- link:http://unhosted.org/using-solid[Up to date overview by Michiel B. de Jong]
      
      
=== Relevant packages

- link:https://github.com/solid/solid-client[solid/solid-client] (deprecated)
- link:https://github.com/solid/solid-auth-client[solid/solid-auth-client] (legacy)
- link:https://github.com/solid/solid-auth-oidc[solid/solid-auth-oidc] (browser)
- link:https://github.com/inrupt/solid-client-authn-js[inrupt/solid-client-authn] (Inrupt)
- link:https://github.com/solid/solid-auth-fetcher[solid/solid-auth-fetcher] (outdated?)
- link:https://github.com/solid/oidc-rs[solid/oidc-rs] (outdated?)
- link:https://github.com/solid/oidc-auth-manager[solid/oidc-auth-manager] (outdated?)
- link:https://github.com/solid/identity-token-verifier[solid/identity-token-verifier]
